#import sockets
from dataclasses import dataclass
import zlib
from typing import List
import struct
from enum import Enum
import threading
# reliable data transfer class 

# we want to send and receive using selective repeat sliding window
# this means that we will call selective repeat function when sending
# or receiving?

# How to establish a connection? We need to make a handshake
# Once we have the connection, we want to send data with
# our window made in selective repeat

# So what will this look like?

#   Server established
#   Client established

#   Client "connects" with server
#   Client sends message through a "reliable channel" (rdt_send())
#   Selective Repeat and other rdt sender steps
#   UDP send -> x.sendto() function (unreliable send)
#   Data goes through unreliable channel

#   UDP receive -> x.recvfrom() function (unreliable receive)
#   Selective Repeat and other rdt receiver steps
#   deliver_data (reliable data delivery to app layer)

#   Server prints out delivered_data
#   Server for now doesn't need to send anything back but maybe we could
#   have the server send something back later?? maybe broadcast?

#   selective repeat sender side (client) takes following as input:
#       encrypted? message (or decrypted message)
#        

# num_packets is computed in main file

#expected_seq_num = 0
packet_size = 256
MAGIC = 0x01051117

# mutex thread for timer
#mutex = _thread.allocate(lock)

class PacketType(Enum):
    Data = 0
    ACK = 1
    NACK = 2

@dataclass
class PcktHeader:
    Magic: int # 4 byte magic code
    Checksum: int # 4 byte CRC32
    ConvID: int # 4 byte ID, perhaps we store this in file later
    SequenceNum: int # 4 byte
    Final: int # 2 bytes
    Type: PacketType # 2 bytes


@dataclass
class Pckt:
    Header: PcktHeader
    Body: str # N bytes

def timeout(packet, socket, address, is_done):
    t = threading.Timer(0.5, timeout, args=(packet, socket, address))
    if (is_done):
        t.cancel()
        return
    socket.sendto(packet, address)
    t.start()

# driver function containing all the rdt requirements
def rdt_send(data, socket, address, convid, pkt_type: PacketType):
    is_done = False 
    magic = MAGIC # always the same
    #convid = 1 # generated by main consensus / server (fnc param)
    sequencenum = 2 # selective repeat generates it
    final = 3 # generated by selective repeat
    # packet type determined as function parameter
    check = 0
    
    packet = make_pckt(data, magic, check, convid, sequencenum, final, pkt_type)

    # send packet to sendto function in main 
    # if we do it like this, how will we do selective repeat?
    # we need socket data type here?
    check = compute_checksum(packet)

    data = extract(packet)

    packet = make_pckt(data, magic, check, convid, sequencenum, final, pkt_type)
    
    t = threading.Timer(0.5, timeout, args=(packet, socket, address, is_done))

    socket.sendto(packet, address)
    t.start()

    is_done = header_receive(socket)

    t.cancel()

    return is_done

def rdt_receive(socket):

    magic = MAGIC

    packet, address = socket.recvfrom(256)

    # we want to keep getting right package
    if (not check_checksum(packet)):
        print("Checksum incorrect!! \n")
        header_send(magic, 0, 0, 0, 0, PacketType.NACK, socket, address)

    else:
        header_send(magic, 0, 0, 0, 0, PacketType.ACK, socket, address)
    
        

    # then check for header information
    # if correct, extract packet
    data = decode_packet(packet)
    # data is of type packet body

    return data, address


# what do we need? window, which is just some array of data?

# for sending acks and nacks
def header_send(magic, check, convid, sequencenum, final, pkt_type, socket, address):
    packet = make_pckt("", magic, check, convid, sequencenum, final, pkt_type)
    checksum = compute_checksum(packet)
    data = extract(packet)
    packet = make_pckt("", magic, checksum, convid, sequencenum, final, pkt_type)
    socket.sendto(packet, address)

def header_receive(socket):
    packet, address = socket.recvfrom(256)
    if (not check_checksum(packet)):
        print("ACK NACK Checksum incorrect!! \n")

    header = decode_header(packet)
    if (header.Type == PacketType.ACK):
        print(f"ACK recieved {header.SequenceNum}")
        return True
    elif (header.Type == PacketType.NACK):
        print("NACK received")

    return False


# function that makes packet with checksum
def make_pckt(data, magic, checksum, conv_id, sequence_num, final, packet_type):
    # this is where we instantiate our class PcktHeader and Pckt
    # and encode the data
    header = PcktHeader(magic, checksum, conv_id, sequence_num, final, packet_type)
    newpckt = Pckt(header, data)
    enc_bytes = encode_packet(newpckt)

    return enc_bytes


# compute the IEEE CRC32 checksum of data
def compute_checksum(packet: Pckt):

    # IEEE CRC32 Polynomial:
    # x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10
    # + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
    # zlib function that calculates crc32

    checksum = zlib.crc32(packet[8:])

    return checksum

def check_checksum(packet: Pckt):
  my_sum = zlib.crc32(packet[8:])
  header = decode_header(packet[:20])
  checksum = header.Checksum
  #print(f"Checksum: {checksum}, Data: {my_sum} \n")

  return checksum == my_sum

def extract(packet):

    ext_pkt = decode_packet(packet)
    return ext_pkt.Body

# Unpack the header bytes
def decode_header(header_bytes):
    magic, checksum, convid, seqnum, final, ptype = struct.unpack('!IIIIHH', header_bytes)
    return PcktHeader(magic, checksum, convid, seqnum, final, PacketType(ptype))


# Unpack whole packet including the body
def decode_packet(packet_bytes):
    header = decode_header(packet_bytes[:20])
    body = packet_bytes[20:]
    decoded_data = body.decode()
    
    return Pckt(header, decoded_data)


# Pack the header
def encode_header(header: PcktHeader):
    return struct.pack('!IIIIHH', header.Magic, header.Checksum, header.ConvID, header.SequenceNum, header.Final, header.Type.value)

# Pack whole packet including the body
def encode_packet(packet: Pckt):
    header_bytes = encode_header(packet.Header)
    body_bytes = packet.Body.encode()#bytes(packet.Body)
    return header_bytes + body_bytes

